% % % % % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%		
% This software is the implementation of the Ariadne algorithm by Nasso et al. 	
% Copyright (C) 2012 Sara Nasso		
%     		
% Ariadne is free software; you can redistribute it and/or modify		
% it under the terms of the GNU General Public License as published by		
% the Free Software Foundation; either version 2 of the License, or (at		
% your option) any later version.		
% 		
% Ariadne is distributed in the hope that it will be useful, but		
% WITHOUT ANY WARRANTY; without even the implied warranty of		
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU		
% General Public License for more details.		
% 		
% You should have received a copy of the GNU General Public License		
% along with this program; if not, write to the Free Software		
% Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307		
% USA		
% % % % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%		

% This script allows to generate transition lists for an SRM (TSQ) experiment
% with fixed dwell time starting from mGen output lists. If many lists are processed
% together they need to have all the same structure (generated by mGen with the option -num_samples)
clc
clear
close all

[fileNames,filePath] = uigetfile('*.*', 'Select the mGen output files to split into runs' ,'MultiSelect', 'on');

prompt = {'Enter the number of runs','Enter dwell time (sec)','Enter scheduling window width (min)','Enter threshold for Thermo on-run ret times realignment','Enter polarity'};
dlg_title = 'Input info';
num_lines = 1;
def = {'2','0.02','6','10000','1'};
answer = inputdlg(prompt,dlg_title,num_lines,def,'on');
numOfRuns=str2num(answer{1});
dwellTime=str2num(answer{2});
schedWinWidth=str2num(answer{3});
thresholdThermo=str2num(answer{4});
polarity=str2num(answer{5});
choice=questdlg('Are you going to use the Thermo on the run ret times realignment (No!)?','Thermo software compliance');
if isequal(choice,'Yes')
    thermoBool=1;
else
    thermoBool=0;
end
if ~iscell(fileNames)
    fileNames={fileNames};
end

choice2=questdlg('Are you going to fix the cycle time?','Thermo t-SRM');
if isequal(choice2,'Yes')
    cycleTime=1;
else
    cycleTime=0;
end

choice2=questdlg('Are you going to separate decoys?');
if isequal(choice2,'Yes')
    decoysApart=1;
else
    decoysApart=0;
end


for i=1:numel(fileNames)
    pause(1)
    java.lang.System.gc();
    fileName=[filePath fileNames{i}]
    if i==1
        [fileRead header]=readTxtLists(fileName);
        idx_dwellTimeCol=listdlg('PromptString','Select the column for dwell time','ListString',header);
        if cycleTime
            fileRead(:,idx_dwellTimeCol)=[];
            header(:,idx_dwellTimeCol)=[];
        end
        %get info from user
        [column,ok] = listdlg('PromptString','Select the column for static transitions:','ListString',header);
        staticTranssIdentifier=fileRead(2:end,column);
        [staticTranssIdentifierUnique idx_staticTranssIdentifierUnique idx_staticTranssIdentifier]=unique(staticTranssIdentifier);
        [staticIdentifier,ok] = listdlg('PromptString','Select the identifier(s) for static transitions:','ListString',staticTranssIdentifierUnique);
        staticTransId=staticTranssIdentifierUnique(staticIdentifier);
        idx_staticTrans_raw = find(ismember(staticTranssIdentifier,staticTransId)==1)+1;
        
        idx_decoys=find(cell2mat(fileRead(2:end,strmatch('decoy',header,'exact')))==1)+1;
        
        idx_staticTrans=setdiff(idx_staticTrans_raw,idx_decoys);
        %get static trans
        staticTrans=fileRead(idx_staticTrans,:);
        
        if decoysApart
            fileRead=fileRead(idx_decoys,:);
            idx_decoys=1:size(fileRead,1);
            idx_staticTrans=1;
        end

        idx_retTimesCol= listdlg('PromptString','Select the column for retention times','ListString',header);
        idx_trsGrpId= listdlg('PromptString','Select the column for trans group id','ListString',header);
        h=waitbar( i / numel(fileNames),'Lists reading and splitting...wait please')
    else
        [fileRead header]=readTxt(fileName);
        if cycleTime
            fileRead(:,idx_dwellTimeCol)=[];
            header(:,idx_dwellTimeCol)=[];
        end
        staticTranssIdentifier=fileRead(2:end,column);
        [staticTranssIdentifierUnique idx_staticTranssIdentifierUnique idx_staticTranssIdentifier]=unique(staticTranssIdentifier);
        idx_staticTrans_raw = find(ismember(staticTranssIdentifier,staticTransId)==1)+1;

        idx_decoys=find(cell2mat(fileRead(2:end,strmatch('decoy',header,'exact')))==1)+1;
        
        idx_staticTrans=setdiff(idx_staticTrans_raw,idx_decoys);
        %get static trans
        staticTrans=fileRead(idx_staticTrans,:);
        
        if decoysApart
            fileRead=fileRead(idx_decoys,:);
            idx_decoys=1:size(fileRead,1);
            idx_staticTrans=1;
        end

    end

    decoys=fileRead(idx_decoys,:);
    %delete read rows
    fileRead(union(idx_decoys,idx_staticTrans),:)=[];
    %sort by retention times
    [prova idx_sorting]=sort(cell2mat(fileRead(2:end,idx_retTimesCol)));
    fileRead_sorted=[header;fileRead(idx_sorting+1,:)];
    %extract different peak groups
    [trGrpIds idx_u ]=unique(fileRead_sorted(2:end,idx_trsGrpId)); % peps--> peak groups
    idx_trGrps=sort(idx_u);
    % initialize empty lists
    for k=1:numOfRuns
        eval(['list' num2str(mod(k,numOfRuns)+1) '=[];'])
        pause(0.01)
    end
    %populate lists with:
    % target peak groups
    for j=1:numel(idx_trGrps)
        currTranss=fileRead_sorted(strmatch(fileRead_sorted(idx_trGrps(j),idx_trsGrpId),fileRead_sorted(:,idx_trsGrpId),'exact'),:);
        eval(['list' num2str(mod(j,numOfRuns)+1) '=[list' num2str(mod(j,numOfRuns)+1) ';currTranss];'])
        clear currTranss
        pause(0.01)
    end
    % static transitions
    for j=1:numOfRuns
        eval(['list' num2str(mod(j,numOfRuns)+1) '=[list' num2str(mod(j,numOfRuns)+1) ';staticTrans];'])
        pause(0.01)
    end
    % decoys (evenly spread)
    for j=1:size(decoys,1)
        currTranss=decoys(j,:);
        eval(['list' num2str(mod(j,numOfRuns)+1) '=[list' num2str(mod(j,numOfRuns)+1) ';currTranss];'])
        clear currTranss
        pause(0.01)
    end
    % export lists for TSQ
    for j=1:numOfRuns
        eval(['getTSQList(list' num2str(mod(j,numOfRuns)+1) ',fileName,header,idx_retTimesCol,idx_dwellTimeCol,schedWinWidth,thresholdThermo,thermoBool,polarity);'])
        pause(0.01)
    end
end
close(h)










	
